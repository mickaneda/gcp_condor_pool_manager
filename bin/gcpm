#!/usr/bin/env bash

GCPM_LICENSE='The MIT License (MIT)

Copyright (c) 2018 Michiru Kaneda

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.'

GCPM_AUTHOR="Michiru Kaneda"
GCPM_VERSION="v0.0.1"
GCPM_DATE="05/Sep/2018"

# Default parameters
core=()
mem=()
disk=()
max=()
max_cores=0
prefix="gcp-wn"
image=()
preemptible=1
off_timer=0
zones=""
tag=""
reuse=0
interval=10
head_info=gcp
bucket=""
admin=""
owner=""
log_level=INFO
log_level_n=1
gcloud="/root/google-cloud-sdk/bin/gcloud"
gcloud_cmd="$gcloud"

PARAMS=(max max_cores prefix core mem disk image preemptible off_timer zones tag reuse interval head_info bucket admin owner log_level gcloud)
PARAMS_NO_EMPTY=(max_cores prefix core mem image head_info bucket admin owner log_level gcloud)

# Config file
config_dir="${HOME}/.config/gcp_condor_pool_manager"
config_file="${config_dir}/config"
wn_list="${config_dir}/wn_list"
startup_prefix="${config_dir}/startup"

# Other variables
pool_password=""
edit=0
system=0
logger_line=0

# HELP
HELP="HTCondor pool manager for Google Cloud Platform

Usage: gcpm  [-esvh] [-f <config file>] [-l <log level>] [-p <pool_password file>]

   -f  <config file>          Set config file
   -l  <log level>            Set log level (DEBUG, INFO (default), NOTICE, WARNING, ERROR)
   -p  <pool_password_file>   Pool file management
   -e                         Edit config file
   -s                         Start system process
   -v                         Show version
   -h                         print this help"

# Logger
LOGGER_LEVELS=("DEBUG" "INFO" "NOTICE" "WARNING" "ERROR")
LOGGER_COLORS=(3 "" 36 33 31)

get_log_level () {
  if [ $# -eq 0 ];then
    local level=1
  else
    local level=$1
  fi
  if [[ ! "$level" =~ ^[0-9]+$ ]];then
    local i=0
    while [[ $i -lt ${#LOGGER_LEVELS[@]} ]];do
      if [[ "$level" = "${LOGGER_LEVELS[$i]}" ]];then
        level=$i
        break
      fi
      ((i++))
    done
  fi
  echo $level
}

get_log_level_name () {
  if [ $# -eq 0 ];then
    local level=INFO
  else
    local level=$1
  fi
  if [[ "$level" =~ ^[0-9]+$ ]];then
    level=${LOGGER_LEVELS[$level]}
  fi
  echo "$level"
}

set_log_level () {
  log_level=$1
  log_level_n=$(get_log_level "$log_level")
}

check_log_level () {
  local level=$1
  local level_n=$(get_log_level "$level")
  [[ "$level_n" -lt "$log_level_n" ]] && return 1
  return 0
}

get_log_color () {
  local level=$1
  local level_n=$(get_log_level "$level")
  echo "${LOGGER_COLORS[$level_n]}"
}

logger () {
  local level=$1
  local line=$logger_line
  logger_line=0
  shift
  check_log_level "$level" || return
  level=$(get_log_level_name "$level")
  local msg="[$level]"
  [[ "$system" -eq 0 ]] && msg="[$(date +'%Y/%m/%d %H:%M:%S')]$msg"
  if [[ "$line" -eq 1 ]];then
    if [[ "$system" -eq 1 ]];then
      local width1=$((40-${#msg}))
      local width2=40
    else
      local width1=$((80-${#msg}))
      local width2=80
    fi
    local linepre=$(eval "printf =%.s {1..$width1}")
    local linepost=$(eval "printf =%.s {1..$width2}")
    msg="${msg}${linepre}\\n$*\\n${linepost}\\n"
  else
    msg="${msg} $*\\n"
  fi
  local out=1
  print_cmd="printf"
  if [[ $level = "ERROR" ]];then
    out=2
    print_cmd=">&2 printf"
  fi
  if test  -t $out;then
    local color=$(get_log_color "$level")
    msg="\\e[${color}m${msg}\\e[m"
  fi
  eval "$print_cmd \"$msg\""
}

debug () {
  logger DEBUG "$*"
}

info () {
  logger INFO "$*"
}

notice () {
  logger NOTICE "$*"
}

warn () {
  logger WARNING "$*"
}

err () {
  logger ERROR "$*"
}

cmd_exec () {
  if [[ $# -eq 1 ]];then
    level=1
  else
    level=$(get_log_level "$1")
    shift
  fi
  logger "$level" "$ $*"
  local out=""
  check_log_level "$level" || out=">/dev/null"
  eval "$* $out"
}

# Functions: Show setup
show_setup () {
  logger_line=1
  notice "Parameters were updated
Configuration file: $config_file
$(for p in "${PARAMS[@]}";do eval "echo \$p = \${$p[@]}";done)"
}

# Functions: Read config function
check_var () {
  local name="$1"
  local var="${2//\"/}"
  local is_num="${3:-0}"
  local no_empty="${4:-0}"
  local array="${4:-0}"
  if [ "$array" -eq 1 ];then
    var=(${var//,/ })
  else
    var=("$var")
  fi
  if [ "${var[*]}" = "$(eval "echo \${$name[*]}")" ];then
    return 0
  fi

  if [ "$is_num" -eq 1 ];then
    for v in "${var[@]}";do
      if [[ ! "$v" =~ ^[0-9]+$ ]];then
        err "must be number, $1 is not allowed for $name. Check your configuration file."
        exit 1
      fi
    done
  fi

  if [ "$no_empty" -eq 1 ];then
    for v in "${var[@]}";do
      if [ -z "$v" ];then
        err "$name must not be empty. Check your configuration file."
        exit 1
      fi
    done
  fi

  if [ "$array" -eq 1 ];then
    eval "$name=(${var[*]})"
  else
    eval "$name=${var[0]}"
  fi
  is_updated=1

  return 0
}

make_startup () {
  # Make startup script

  mkdir -p "$config_dir"
  local i=0
  for ((i=0;i<${#core[@]};i++));do
    cat << EOF > "${startup_prefix}-${core[$i]}core.sh"
#/bin/bash
sed -i"" 's/FIXME_ADMIN/${admin}/' /etc/condor/config.d/00_config_local.config

sed -i"" 's/FIXME_HOST/${head}/' /etc/condor/config.d/10_security.config
sed -i"" 's/FIXME_DOMAIN/${domain}/' /etc/condor/config.d/10_security.config
sed -i"" "s/FIXME_PRIVATE_DOMAIN/\$(hostname -d)/" /etc/condor/config.d/10_security.config

sed -i"" 's/FIXME_OWNER/${owner}/' /etc/condor/config.d/20_workernode.config
sed -i"" 's/FIXME_CORE/${core[$i]}/' /etc/condor/config.d/20_workernode.config
sed -i"" 's/FIXME_MEM/${mem[$i]}/' /etc/condor/config.d/20_workernode.config

gsutil cp "${bucket}/pool_password" /etc/condor/
chmod 600 /etc/condor/pool_password
systemctl enable condor
systemctl start condor
while :;do
  condor_reconfig
  status="\$(condor_status | grep "\${HOSTNAME}")"
  if [ -n "\$status" ];then
    break
  fi
  sleep 10
done
date > /root/condor_started
EOF
    if [ $off_timer -ne 0 ];then
      cat << EOF >> "${startup_prefix}-${core[$i]}core.sh"
sleep $off_timer
condor_off -peaceful -startd
date > /root/condor_off
EOF
    fi
  done
}

read_config () {
  if [ ! -f "$config_file" ];then
    err "Configuration file:$config_file doesn't exist"
    exit 1
  else
    is_updated=0
    local line
    while read -r line;do
      line=(${line%%#*})
      local name=${line[0]}
      if [[ -z "$name" ]];then
        continue
      fi
      local var=${line[1]}
      if [ "$name" = "max" ];then
        check_var max "$var" 1 1 1
      elif [ "$name" = "max_cores" ];then
        check_var max_cores "$var" 1 1
      elif [ "$name" = "prefix" ];then
        check_var prefix "$var" 0 1
      elif [ "$name" = "core" ];then
        check_var core "$var" 1 1 1
      elif [ "$name" = "mem" ];then
        check_var mem "$var" 1 1 1
      elif [ "$name" = "disk" ];then
        check_var disk "$var" 0 1 1
      elif [ "$name" = "image" ];then
        check_var image "$var" 0 1 1
      elif [ "$name" = "preemptible" ];then
        check_var preemptible "$var" 1 1
      elif [ "$name" = "off_timer" ];then
        check_var off_timer "$var" 1 1
      elif [ "$name" = "zones" ];then
        check_var zones "$var" 0 0
        zones=$(echo "$var"|tr , ' ')
      elif [ "$name" = "tag" ];then
        check_var tag "$var" 0 0
      elif [ "$name" = "reuse" ];then
        check_var reuse "$var" 1 1
      elif [ "$name" = "interval" ];then
        check_var interval "$var" 1 1
      elif [ "$name" = "head_info" ];then
        check_var head_info "$var" 0 1
      elif [ "$name" = "bucket" ];then
        check_var bucket "$var" 0 1
      elif [ "$name" = "admin" ];then
        check_var admin "$var" 0 1
      elif [ "$name" = "owner" ];then
        check_var owner "$var" 0 1
      elif [ "$name" = "log_level" ];then
        check_var log_level "$var" 0 1
        set_log_level "$log_level"
      elif [ "$name" = "gcloud" ];then
        check_var gcloud "$var" 0 1
      else
        warn "$name is not valid parameter"
      fi
    done < "$config_file"
  fi

  # No reuse for non zero off timer nodes
  if [ $off_timer -ne 0 ];then
    reuse=0
  fi

  # check variables
  for v in "${PARAMS_NO_EMPTY[@]}";do
    if [ -z "$(eval "echo \$$v")" ];then
      err "$v must not be empty"
      exit 1
    fi
  done

  if [ ${#core[@]} -gt ${#max[@]} ];then
    err "core and max have different number of definitions"
    exit 1
  fi
  if [ ${#core[@]} -gt ${#mem[@]} ];then
    err "core and memory have different number of definitions"
    exit 1
  fi

  if [ $is_updated -eq 1 ];then
    show_setup
  else
    return
  fi

  # Set head information, and make startup script
  if [ "$head_info" = "hostname" ];then
    head=${HOSTNAME}
  elif [ "$head_info" = "ip" ];then
    head=$(hostname -i)
  elif [ "$head_info" = "gcp" ];then
    head=${HOSTNAME}
  else
    head=$head_info
  fi
  domain=$(hostname -d)
  make_startup

  # make prefix for each core
  prefix_core=()
  for ((i=0;i<${#core[@]};i++));do
    prefix_core[$i]=${prefix}-${core[$i]}core
  done

  # Fix bucket
  if [[ ! $bucket =~ gs://* ]];then
    bucket="gs://$bucket"
  fi

  # Set gcloud options
  if type "$gcloud" >&/dev/null;then
    gcloud_cmd=$gcloud
  else
    gcloud_cmd=gcloud
  fi
  option=""
  filter=""
  zone=""
  if [ "$preemptible" -eq 1 ];then
    option="${option} --preemptible"
  fi
  if [ -n "$zones" ];then
    filter="--filter=\"zone:($(echo "$zones"|tr , ' '))\""
    zone="--zone=$(echo "$zones"|tr , ' '|cut -d' ' -f1)"
    option="${option} ${zone}"
  fi
  if [ -n "$tag" ];then
    option="${option} --tags=$tag"
  fi
}

# Functions: Update worker node information
update_wns () {
  # update condor configuration for worker nodes
  local names=()
  local ips=()

  # Get running instances
  local line
  while read -r line;do
    local instance=($line)
    local name=${instance[0]}
    local state=${instance[((${#instance[@]}-1))]}
    if [ "$head_info" = "gcp" ];then
      local ip=${instance[((${#instance[@]}-3))]}
    else
      local ip=${instance[((${#instance[@]}-2))]}
    fi
    if [ "$state" == "RUNNING" ];then
      names=("${names[@]}" "${name}")
      ips=("${ips[@]}" "${ip}")
    fi
  done < <(eval $gcloud_cmd compute instances list $filter|grep "^$prefix")

  # Check instance which is not running, but in condor_status (should be in the list until it is removed from the status)
  local in_status=($(condor_status -autoformat Name|cut -d"." -f1))
  mkdir -p "$config_dir"
  touch "$wn_list"
  local wn
  for wn in "${in_status[@]}";do
    if ! echo " ${names[*]} "|grep -q " $wn ";then
      local ip=$(grep "$wn" "$wn_list"|cut -d" " -f2)
      if [ -n "$ip" ];then
        names=("${names[@]}" "${wn}")
        ips=("${ips[@]}" "${ip}")
      else
        warn "$wn is listed in the status, but not listed in $wn_list nor gcp pool"
      fi
    fi
  done

  # Make wn list
  local n=0
  local wns=""
  : > "$wn_list"
  while [ $n -lt ${#names[@]} ];do
    wns="$wns condor@\$(UID_DOMAIN)/${ips[$n]} condor_pool@\$(UID_DOMAIN)/${ips[$n]}"
    echo "${names[$n]} ${ips[$n]}" >> "$wn_list"
    ((n++))
  done

  # Update config for collector
  local out=""
  if check_log_level DEBUG;then
    debug "$ condor_config_val -collector -set 'WNS = ${wns//\$/\\\$}'"
  else
    out=">/dev/null"
  fi
  eval "condor_config_val -collector -set 'WNS = $wns' $out"
  cmd_exec DEBUG "condor_reconfig -collector"
}

# Functions: Clean up worker nodes
clean_wns () {
  # Delete instances not in condor_status, which were removed by condor_off
  local in_status=("$(condor_status -autoformat Name|cut -d"." -f1)")
  local is_deleted=0
  while read -r line;do
    instance=($line)
    name=${instance[0]}
    if [[ "${in_status[*]}" != *${name}* ]];then
      cmd_exec "echo y|$gcloud_cmd compute instances delete ${name} $zone"
      is_deleted=1
    fi
  done < <(eval $gcloud_cmd compute instances list $filter|grep "^$prefix")
  if [ $is_deleted -eq 1 ];then
    update_wns
  fi
}

#### Start script ###

# Check arguments
while getopts esvhf:l:p: OPT;do
  case $OPT in
    "f" ) config_file=$OPTARG;;
    "l" ) set_log_level "$OPTARG";;
    "p" )
      pool_password=$OPTARG
      if [ -z "$pool_password" ];then
        err "pool_password file is empty"
        exit 1
      fi
      ;;
    "e" ) edit=1;;
    "s" )
      system=1
      config_dir="/var/cache/gcpm"
      config_file="/etc/gcpm.conf"
      wn_list="/var/cache/gcpm/wn_list"
      startup_prefix="/var/cache/gcpm/startup"
      ;;
    "v" ) echo "version: $GCPM_VERSION, date: $GCPM_DATE, author: $GCPM_AUTHOR"; exit;;
    "h" ) echo "$HELP"; exit;;
    * ) echo "Unknown arguments: $OPT"; echo; echo "$HELP"; exit 1;;
  esac
done

if [[ "$system" -eq 1 ]];then
  logger_line=1
  notice "Starting gcpm"
fi

# Read configuration file
read_config

# Edit
if [ "$edit" -eq 1 ];then
  ${EDITOR:-vi} "$config_file"
  exit $?
fi

# pool_password management
if [ -n "$pool_password" ];then
  if ! gsutil ls | grep "${bucket}$" >/dev/null;then
    z=${zone#*=}
    z=${z%-*}
    cmd_exec "gsutil mb -c coldline -l $z $bucket"
    ret=$?
    if [ $ret -ne 0 ];then
      exit $ret
    fi
  fi
  cmd_exec "gsutil cp $pool_password ${bucket}"
  ret=$?
  exit $ret
fi

# Check gcloud utils
if ! type $gcloud_cmd >& /dev/null;then
  if [[ $system -eq 0 ]];then
    message="gcloud tools are not installed, do you want to install?"
    while : ;do
      echo "$message [y/n]: " >/dev/tty
      read -srn 1 ans </dev/tty
      if [ "$ans" = "y" ];then
        curl https://sdk.cloud.google.com | bash
        echo "Setup gcloud's account"
        exit
      elif [ "$ans" = "n" ];then
        err "Intall gcloud: https://cloud.google.com/sdk/install"
        exit 1
      fi
    done
  else
    err "Intall gcloud: https://cloud.google.com/sdk/install"
    exit 1
  fi
fi

gcloud_auth_list=$(echo && $gcloud_cmd config list 2>&1)
notice "$gcloud_auth_list"
if [[ "$gcloud_auth_list" != *account\ *project\ * ]];then
  err "Set account/project for gcloud"
  exit 1
fi

# Check condor
condor_status >&/dev/null
ret=$?
if [[ $ret -eq 1 ]];then
  err "condor seems not running, please check"
  exit 1
elif [[ $ret -ne 0 ]];then
  err "Please install HTCondor"
  exit 1
fi

# Update worker nodes at first
update_wns

# Main loop
while :;do
  # Update configuration
  read_config

  # Cleanup worker nodes
  clean_wns

  # Check instances
  all=()
  terminated=()
  if [[ $max_cores -ne 0 ]];then
    total_cores=0
  fi
  while read -r line;do
    core_check=0
    for pc in "${prefix_core[@]}";do
      if [[ "$line" == ${pc}* ]];then
        core_check=1
        break
      fi
    done
    [[ $core_check -eq 0 ]] && continue

    instance=($line)
    name=${instance[0]}
    state=${instance[((${#instance[@]}-1))]}
    add=0
    if [ "$state" == "TERMINATED" ];then
      if [ $reuse -eq 1 ];then
        add=1
        terminated=("${terminated[@]}" "${name}")
      else
        cmd_exec "echo y|$gcloud_cmd compute instances delete ${name} $zone"
        # Update worker node information
        update_wns
      fi
    elif [ "$state" == "RUNNING" ];then
      add=1
    fi
    if [ $add -eq 1 ];then
      all=("${all[@]}" "${name}")
      if [[ $max_cores -ne 0 ]];then
        for p in "${prefix_core[@]}";do
          if [[ "$name" == ${p}* ]];then
            n_core=${p#${prefix}-}
            n_core=${n_core%core}
            total_cores=$((total_cores+n_core))
          fi
        done
      fi
    fi
  done < <(eval $gcloud_cmd compute instances list $filter|grep "^$prefix")

  for((i=0;i<${#core[@]};i++));do
    n_idle=$(condor_q -allusers -global -af JobStatus RequestCpus|grep -c "^1 ${core[$i]}$")
    if [ "$n_idle" -eq 0 ];then
      continue
    fi
    machines="$(condor_status -autoformat Name State|grep "${prefix_core[$i]}")"
    n_machines=$(echo "$machines"|wc -l)
    n_unclaimed=$(echo "$machines"|grep -c " Unclaimed")

    if [[ $n_unclaimed -eq 0 && $((total_cores+${core[$i]})) -le $max_cores && $n_machines -lt ${max[$i]} ]];then
      # start/create instance
      instance_name=""
      for instance in "${terminated[@]}";do
        if [[ $instance == ${prefix_core[$i]}* ]];then
          instance_name=$instance
          cmd_exec "$gcloud_cmd compute start $instance_name"
          echo ""
        fi
      done
      if [ -z "$instance_name" ];then
        n=1
        while [ $n -lt 10000 ];do
          instance_name=${prefix_core[$i]}-$(printf "%04d" $n)
          if ! echo "${all[*]}"|grep -q "$instance_name";then
            startup="${startup_prefix}-${core[$i]}core.sh"
            if [[ ! -f "$startup" ]];then
              make_startup
            fi
            custom_memory=$(((mem[$i]/256+1)*256))
            custom_image=${image[$i]}
            if [[ -z "$custom_image" ]];then
              custom_image=${image[0]}
            fi
            gcloud_option="$option --image ${custom_image} --custom-cpu ${core[$i]} --custom-memory ${custom_memory}MB"
            if [[ -n "${disk[$i]}" ]];then
              gcloud_option="$gcloud_option --boot-disk-size ${disk[$i]}GB"
            fi
            cmd_exec "$gcloud_cmd compute instances create $instance_name --metadata-from-file startup-script=\"${startup}\" $gcloud_option"
            break
          fi
          instance_name=""
          ((n++))
        done
      fi
      if [ -n "$instance_name" ];then
        # Update worker node information
        update_wns

        # Check new instance in the pool
        try=0
        while :;do
          if condor_status |grep -q "$instance_name" ;then
            info "$instance_name is added in the pool"
            if [[ $max_cores -ne 0 ]];then
              total_cores=$((total_cores+${core[$i]}))
            fi
            break
          fi
          ((try++))
          if [ $try -gt 100 ];then
            warn "$instance_name is still not available in the condor pool.
Please check $instance_name status"
            break
          fi
          sleep 1
        done
      fi
    fi
  done
  sleep $interval
done
